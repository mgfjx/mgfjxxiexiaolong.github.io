{"meta":{"title":"mgfjx","subtitle":null,"description":null,"author":"mgfjxxiexiaolong","url":"http://yoursite.com"},"pages":[{"title":"改网页无法正常显示！请稍后再试！","date":"2017-01-17T08:54:31.000Z","updated":"2017-01-17T08:55:06.000Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-01-17T08:25:55.000Z","updated":"2017-01-17T08:25:55.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我的个人简介"},{"title":"tags","date":"2017-01-17T08:27:48.000Z","updated":"2017-01-18T07:55:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Shell"}],"posts":[{"title":"Xcode tips","slug":"Xcode-tips","date":"2017-05-08T06:00:04.000Z","updated":"2017-05-08T06:19:28.000Z","comments":true,"path":"2017/05/08/Xcode-tips/","link":"","permalink":"http://yoursite.com/2017/05/08/Xcode-tips/","excerpt":"","text":"1、Xcode 8.3无法使用PackageApplication提示：xcrun: error: unable to find utility &quot;PackageApplication&quot;, not a developer tool or in PATH.解决办法: 从Xcode 8.2拷贝PackageApplication到当先Xcode对应目录1) 下载PackageApplication:https://gist.github.com/anonymous/48f3e4c5ae25313dc0fe10d9ec50c3fc2) 修改属性为可执行: chmod +x PackageApplication3) 拷贝到对应目录: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication参考地址","categories":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/categories/Xcode/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"shell-tr命令","slug":"shell-tr命令","date":"2017-05-02T00:46:29.000Z","updated":"2017-05-02T01:31:05.000Z","comments":true,"path":"2017/05/02/shell-tr命令/","link":"","permalink":"http://yoursite.com/2017/05/02/shell-tr命令/","excerpt":"作用：tr 命令用于转换字符、删除字符和压缩重复的字符。它从标准输入读取数据并将结果输出到标准输出。 语法：tr [OPTION]... SET1 [SET2].如果参数 SET1 和 SET2 同时制定，并没有指定 -d 选项，那么 tr 命令将把 SET1 中指定的每个字符替换为 SET2 中相同位置的字符。","text":"作用：tr 命令用于转换字符、删除字符和压缩重复的字符。它从标准输入读取数据并将结果输出到标准输出。 语法：tr [OPTION]... SET1 [SET2].如果参数 SET1 和 SET2 同时制定，并没有指定 -d 选项，那么 tr 命令将把 SET1 中指定的每个字符替换为 SET2 中相同位置的字符。 ####示例：1.将输出文本转换为大写：cat filename | tr [:lower:] [:upper:]，还可以这样写：cat filename | tr a-z A-Z.2.转换一个文件的内容，并将转换的结果输出到另一个文件：tr &#39;originStr&#39; &#39;replaceStr&#39; &lt; originFileName &gt; newFileName.3.使用-d选项删除指定字符：echo &quot;My Name Is Toby&quot; | tr -d a-z,删除所有小写字母.","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"React-Native笔记","slug":"React-Native笔记","date":"2017-03-22T00:24:39.000Z","updated":"2017-03-22T00:56:31.000Z","comments":true,"path":"2017/03/22/React-Native笔记/","link":"","permalink":"http://yoursite.com/2017/03/22/React-Native笔记/","excerpt":"","text":"1、RN调用OC传参并调用方法1)建一个类继承自NSObject的类首先要导入#import &quot;RCTBridgeModule.h&quot;头文件，并遵守RCTBridgeModule协议,然后在实现类中： 1234#import \"RCTBridgeModule.h\"@interface MineRNBridgeModule : RCTEventEmitter&lt;RCTBridgeModule&gt;@end 12345678910#import \"MineRNBridgeModule.h\"@implementation MineRNBridgeModuleRCT_EXPORT_MODULE(MineRNBridgeModule);RCT_EXPORT_METHOD(RunOCMethod:(NSDictionary *)dictionary)&#123; NSLog(@\"接收到RN传过来的数据为:%@\",dictionary); //可以在此添加OC代码操作, RunOCMethod为方法名，后面的为参数&#125;@end 2)RN中实现代码:首先要引入NativeModules组件： 123var RNBridgeModule = NativeModules.MineRNBridgeModule;//在合适位置调用即可RNBridgeModule.RNInvokeOCCallBack(&#123;'name':'jiangqq','description':'http://www.lcode.org'&#125;); 2、OC向RN传参并调用方法参考: React-Native新版本RCTEventEmitter的使用（从原生发送消息到JS）1)自定义的模块类头文件要继承自RCTEventEmitter@interface ChivoxISE : RCTEventEmitter&lt;RCTBridgeModule&gt;2)然后要导出你所有的方法名字 1234- (NSArray&lt;NSString *&gt; *)supportedEvents &#123; return @[@\"iseCallback\", @\"iseVolume\", @\"playCallback\"];//有几个就写几个 &#125; 3)分别实现你导出的所有方法，里面都使用sendEventWithName方法即可 12345678-(void)iseCallback:(NSString*)code result:(NSString*) result &#123; [self sendEventWithName:@\"iseCallback\" body:@&#123; @\"code\": code, @\"result\": result, &#125;]; &#125; 4)最后JS端调用 1234567891011121314151617import &#123; ... NativeModules, NativeEventEmitter, //导入NativeEventEmitter模块 &#125; from 'react-native'; var ChivoxISE = NativeModules.ChivoxISE; const myNativeEvt = new NativeEventEmitter(ChivoxISE); //创建自定义事件接口 //在组件中使用 componentWillMount() &#123; this.listener = myNativeEvt.addListener('iseCallback', this.iseCallback.bind(this)); //对应了原生端的名字 &#125; componentWillUnmount() &#123; this.listener &amp;&amp; this.listener.remove(); //记得remove哦 this.listener = null; &#125;","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"PIL(Python Image Library)详解","slug":"PIL-Python-Image-Library-详解","date":"2017-03-10T03:10:08.000Z","updated":"2017-03-10T06:07:43.000Z","comments":true,"path":"2017/03/10/PIL-Python-Image-Library-详解/","link":"","permalink":"http://yoursite.com/2017/03/10/PIL-Python-Image-Library-详解/","excerpt":"","text":"1、打开、旋转、显示(默认图片浏览器)图片123from PIL import Imageim = Image.open(\"bride.jpg\")im.rotate(45).show() 2、创建缩略图12345678910from PIL import Imageimport glob, ossize = 128, 128for infile in glob.glob(\"*.jpg\"): file, ext = os.path.splitext(infile) im = Image.open(infile) im.thumbnail(size, Image.ANTIALIAS) im.save(file + \".thumbnail\", \"JPEG\") 为当前文件夹下所有JPG图片创建缩略图并存储","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"swift笔记","slug":"swift笔记","date":"2017-02-24T07:29:22.000Z","updated":"2017-02-28T03:15:49.000Z","comments":true,"path":"2017/02/24/swift笔记/","link":"","permalink":"http://yoursite.com/2017/02/24/swift笔记/","excerpt":"1.打印方法名称print(#function); swift3.0 or later(之前为__FUNCTION__) 2.swift使用block(闭包)回调先声明闭包typealias ScanFinish = (_ finish:Bool)-&gt;Void;再设置闭包函数为属性var block:ScanFinish?;,然后在初始化是赋值闭包属性就行了 3.@escaping 逃逸闭包swift3.0总取消了@noescapting(非逃逸闭包)，改为了@escaping(逃逸闭包)，区别：即闭包在函数内执行为非逃逸闭包，在函数外为逃逸闭包，在函数外执行需要@escaping修饰，例如：123456typealias ScanFinish = (_ finish:Bool)-&gt;Void;init(scanFinish: @escaping ScanFinish) &#123; super.init(nibName: nil, bundle: nil); self.block = scanFinish;//逃逸闭包 scanFinish(ture);//非逃逸闭包 &#125;","text":"1.打印方法名称print(#function); swift3.0 or later(之前为__FUNCTION__) 2.swift使用block(闭包)回调先声明闭包typealias ScanFinish = (_ finish:Bool)-&gt;Void;再设置闭包函数为属性var block:ScanFinish?;,然后在初始化是赋值闭包属性就行了 3.@escaping 逃逸闭包swift3.0总取消了@noescapting(非逃逸闭包)，改为了@escaping(逃逸闭包)，区别：即闭包在函数内执行为非逃逸闭包，在函数外为逃逸闭包，在函数外执行需要@escaping修饰，例如：123456typealias ScanFinish = (_ finish:Bool)-&gt;Void;init(scanFinish: @escaping ScanFinish) &#123; super.init(nibName: nil, bundle: nil); self.block = scanFinish;//逃逸闭包 scanFinish(ture);//非逃逸闭包 &#125;","categories":[],"tags":[]},{"title":"fuck shit","slug":"fuck-shit","date":"2017-01-23T03:20:17.000Z","updated":"2017-01-23T06:40:07.000Z","comments":true,"path":"2017/01/23/fuck-shit/","link":"","permalink":"http://yoursite.com/2017/01/23/fuck-shit/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Shell 使用小技巧","slug":"Shell使用小技巧","date":"2017-01-18T07:28:04.000Z","updated":"2017-04-28T06:38:04.000Z","comments":true,"path":"2017/01/18/Shell使用小技巧/","link":"","permalink":"http://yoursite.com/2017/01/18/Shell使用小技巧/","excerpt":"1、sed &#39;s/}/text}/g&#39; file:在文件file文件中的所有}之前添加text文本.例如:NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));打印当前方法名 waring:如果遇到sed: RE error: illegal byte sequence, 这是因为在识别含有多字节编码字符时遇到了解析冲突问题, 请在终端执行export LC_COLLATE=&#39;C&#39;和export LC_CTYPE=&#39;C&#39; 2、将文件夹下的所有文件或文件夹按字母分类123456789101112131415161718#! /usr/bin/bashpath=$1final=$&#123;path: -1&#125;echo final : $finalif [[ \"$&#123;final&#125;\" != \"/\" ]]; then path=$path/; echo hehe + $path;fiecho $pathfor file in `ls $path`;do subDir=$&#123;file:0:1&#125;; subDir=\"$(echo $subDir | tr '[A-Z]' '[a-z]')\" dirPath=$path$subDir; mkdir $dirPath; cp $path$file $dirPath;done","text":"1、sed &#39;s/}/text}/g&#39; file:在文件file文件中的所有}之前添加text文本.例如:NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));打印当前方法名 waring:如果遇到sed: RE error: illegal byte sequence, 这是因为在识别含有多字节编码字符时遇到了解析冲突问题, 请在终端执行export LC_COLLATE=&#39;C&#39;和export LC_CTYPE=&#39;C&#39; 2、将文件夹下的所有文件或文件夹按字母分类123456789101112131415161718#! /usr/bin/bashpath=$1final=$&#123;path: -1&#125;echo final : $finalif [[ \"$&#123;final&#125;\" != \"/\" ]]; then path=$path/; echo hehe + $path;fiecho $pathfor file in `ls $path`;do subDir=$&#123;file:0:1&#125;; subDir=\"$(echo $subDir | tr '[A-Z]' '[a-z]')\" dirPath=$path$subDir; mkdir $dirPath; cp $path$file $dirPath;done 用法：bash script.sh /directory/path 3、find技巧1.批量查找并拷贝到指定目录：find path -name &quot;*.gif&quot;| xargs -I {} cp {} targetPath 2.查找指定路径下所有文件并忽略隐藏文件及隐藏文件夹下的所有文件：find &lt;dir&gt; -path &quot;*/.*&quot; -prune -o -print 3.查找指定路径下指定文件并忽略隐藏文件及隐藏文件夹下的所有文件：find $PWD -path &#39;*/.*&#39; -prune -o \\( -name &#39;*.py&#39; -o -name &quot;*.sh&quot; \\) -type f -print","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"UIView的生命周期","slug":"UIView的生命周期","date":"2017-01-13T16:00:00.000Z","updated":"2017-01-23T02:17:52.000Z","comments":true,"path":"2017/01/14/UIView的生命周期/","link":"","permalink":"http://yoursite.com/2017/01/14/UIView的生命周期/","excerpt":"探寻UIView的生命周期。我们知道view的创建有init(或new)的方法，销毁时会自动执行dealloc方法，但是UIView的生命周期到底是怎样的呢？我们一步一步来。 首先新建一个项目并创建一个TestView继承自UIView： 再创建TestViewController继承自UIViewController，用于承载TestView(方便后面测试view销毁时间)：","text":"探寻UIView的生命周期。我们知道view的创建有init(或new)的方法，销毁时会自动执行dealloc方法，但是UIView的生命周期到底是怎样的呢？我们一步一步来。 首先新建一个项目并创建一个TestView继承自UIView： 再创建TestViewController继承自UIViewController，用于承载TestView(方便后面测试view销毁时间)：在Main.storyboard中给默认的控制器ViewController添加导航：在ViewController.m中添加如下代码用于跳转操作：123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame = CGRectMake(100, 100, 100, 100); btn.backgroundColor = [UIColor colorWithRed:0.489 green:0.548 blue:0.898 alpha:1.000]; [btn setTitle:@\"push\" forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [btn addTarget:self action:@selector(pushTestViewVC:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;- (void)pushTestViewVC:(UIButton *)sender&#123; TestViewController *vc = [[TestViewController alloc] init]; [self.navigationController pushViewController:vc animated:YES]; &#125; 在TestViewController.m中添加如下代码:12345678910- (void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; TestView *view = [[TestView alloc] init]; view.frame = CGRectMake(8, 100, self.view.bounds.size.width - 8*2, 250); view.backgroundColor = [UIColor colorWithRed:0.101 green:0.502 blue:0.427 alpha:1.000]; [self.view addSubview:view]; &#125; ok,到这儿准备工作完成。运行一下： 查看UIViewapi，常用的加载时机大概如下：- (void)layoutSubviews- (void)didAddSubview:(UIView *)subview;- (void)willRemoveSubview:(UIView *)subview;- (void)willMoveToSuperview:(nullable UIView *)newSuperview;- (void)didMoveToSuperview;- (void)willMoveToWindow:(nullable UIWindow *)newWindow;- (void)didMoveToWindow;- (void)removeFromSuperview- (void)dealloc一一在TestView.m中实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import \"TestView.h\"@interface TestView ()&#123; NSInteger count;&#125;@end@implementation TestView- (instancetype)init&#123; self = [super init]; if (self) &#123; count = 0; &#125; return self;&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)didAddSubview:(UIView *)subview&#123; [super didAddSubview:subview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)willRemoveSubview:(UIView *)subview&#123; [super willRemoveSubview:subview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)willMoveToSuperview:(nullable UIView *)newSuperview&#123; [super willMoveToSuperview:newSuperview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)didMoveToSuperview&#123; [super didMoveToSuperview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)willMoveToWindow:(nullable UIWindow *)newWindow&#123; [super willMoveToWindow:newWindow]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)didMoveToWindow&#123; [super didMoveToWindow]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)removeFromSuperview&#123; [super removeFromSuperview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)dealloc&#123; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;@end *_cmd表示当前方法的SEL，既执行该方法时打印方法名* 运行，点push，控制台打印如下： 然后点击navigation的back按钮： 我们发现- (void)didAddSubview:(UIView *)subview;- (void)willRemoveSubview:(UIView *)subview;这两个是需要有子视图才能执行，暂时不做讨论。可以看出上面方法中只会执行一次的方法有removeFromSuperview、dealloc两个方法(layoutSubviews在子视图布局变动时会多次调用)，所以可以在这两个方法中执行释放内存等操作(e.g:移除观察者，定时器等)。 OK，下面我们讨论关于subView的几个方法，首先在TestViewController.m中实现点击按钮给testView添加子视图的功能： 123456789101112131415161718192021222324252627282930313233#import \"TestViewController.h\"#import \"TestView.h\"@interface TestViewController ()&#123; TestView *testView;&#125;@end@implementation TestViewController- (void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithTitle:@\"addSubView\" style:UIBarButtonItemStylePlain target:self action:@selector(addTestViewSubView)]; self.navigationItem.rightBarButtonItem = item; TestView *view = [[TestView alloc] init]; view.frame = CGRectMake(8, 100, self.view.bounds.size.width - 8*2, 250); view.backgroundColor = [UIColor colorWithRed:0.101 green:0.502 blue:0.427 alpha:1.000]; [self.view addSubview:view]; testView = view; &#125;- (void)addTestViewSubView&#123; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)]; view.backgroundColor = [UIColor lightGrayColor]; view.tag = 100; [testView addSubview:view]; &#125;@end 点击push后点击按钮添加子视图：可见didAddSubview和layoutSubviews都调用了，那我们pop回去：willRemoveSubview是在dealloc后面执行的，通过断点我们发现确实是最后执行的。而且如果有多个子视图，willRemoveSubview会循环执行，直到移除所有子视图。 以上执行顺序比较清楚，主要是了解UIView的各个时机便于我们进行相关操作。关于：- (void)willMoveToSuperview:(nullable UIView *)newSuperview;- (void)willMoveToWindow:(nullable UIWindow *)newWindow;这俩个方法可以根据参数是否为nil判断是创建操作还是销毁操作，nil则为销毁，反之，则为创建；- (void)didMoveToSuperview;这个方法可以根据self.superview的值判定，nil则为销毁，反之，则为创建。- (void)didMoveToWindow;这个方法可以根据self.superview的值判定，nil则为创建，反之，则为销毁。(注意这个方法和上面的是相反的) 如有错误的地方，麻烦指正。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}