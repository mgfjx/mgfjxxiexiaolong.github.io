{"meta":{"title":"mgfjx","subtitle":null,"description":null,"author":"mgfjxxiexiaolong","url":"http://yoursite.com"},"pages":[{"title":"改网页无法正常显示！请稍后再试！","date":"2017-01-17T08:54:31.000Z","updated":"2017-01-17T08:55:06.000Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-11-11T14:14:10.000Z","updated":"2017-01-17T08:25:55.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我的个人简介"},{"title":"tags","date":"2017-01-17T08:27:48.000Z","updated":"2017-01-18T07:55:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Shell"}],"posts":[{"title":"隐私协议","slug":"隐私协议","date":"2019-04-13T11:03:15.000Z","updated":"2019-04-13T16:06:18.040Z","comments":true,"path":"2019/04/13/隐私协议/","link":"","permalink":"http://yoursite.com/2019/04/13/隐私协议/","excerpt":"","text":"本隐私声明适用于本应用的所有相关服务，随着本应用服务范围的扩大，隐私声明的内容可由本应用随时更新，且毋须另行通知。更新后的隐私声明一旦在网页上公布即有效代替原来的隐私声明。我们收集哪些信息通常，您能在匿名的状态下访问本应用并获取信息，本应用不会收集用户任何信息。当我们需要能识别您的个人信息或者可以与您联系的信息时，我们会征求您的同意。1、关于您的个人信息本应用严格保护您个人信息的安全。我们使用各种安全技术和程序来保护您的个人信息不被未经授权的访问、使用或泄漏。本应用会在法律要求或符合本应用的相关服务条款、软件许可使用协议约定的情况下透露您的个人信息，或者有充分理由相信必须这样做才能：满足法律或行政法规的明文规定，或者符合本应用网站适用的法律程序；符合本应用相关服务条款、软件许可使用协议的约定；保护本应用的权利或财产，以及在紧急情况下保护本应用员工、本应用产品或服务的用户或大众的个人安全。本应用不会未经您的允许将这些信息与第三方共享，本声明已经列出的上述情况除外。2、关于免责说明就下列相关事宜的发生，本应用不承担任何法律责任：由于您将用户密码告知他人或与他人共享注册帐户，由此导致的任何个人信息的泄漏，或其他非因本应用原因导致的个人信息的泄漏；本应用根据法律规定或政府相关政策要求提供您的个人信息；任何第三方根据本应用各服务条款及声明中所列明的情况使用您的个人信息，由此所产生的纠纷；任何由于黑客攻击、电脑病毒侵入或政府管制而造成的暂时性网站关闭；因不可抗力导致的任何后果；本应用在各服务条款及声明中列明的使用方式或免责情形。","categories":[],"tags":[]},{"title":"Cycript用法","slug":"Cycript用法","date":"2018-02-01T01:02:58.000Z","updated":"2018-02-01T02:59:06.380Z","comments":true,"path":"2018/02/01/Cycript用法/","link":"","permalink":"http://yoursite.com/2018/02/01/Cycript用法/","excerpt":"","text":"1. 打印当前视图层次结构UIApp.keyWindow.recursiveDescription().toString() 2. 获取对象属性123456789function tryPrintIvars(a)&#123; var x=&#123;&#125;; for(i in *a)&#123; try&#123; x[i] = (*a)[i]; &#125; catch(e)&#123;&#125; &#125; return x; &#125;","categories":[],"tags":[]},{"title":"jailbreak tools合集","slug":"jailbreak-tools合集","date":"2018-01-30T05:24:56.000Z","updated":"2018-01-30T06:05:25.594Z","comments":true,"path":"2018/01/30/jailbreak-tools合集/","link":"","permalink":"http://yoursite.com/2018/01/30/jailbreak-tools合集/","excerpt":"","text":"1. ipa砸壳工具1.1 frida-ios-dump条件: 在mac和iOS设备安装frida: mac端安装: 终端执行sudo pip install frida(若失败，尝试python -m pip install frida); iOS端安装: 打开Cydia添加源https://build.frida.re, 再搜索frida安装. 安装: 终端执行git clone git@github.com:AloneMonkey/frida-ios-dump.git. 使用: 终端执行frida-ps -U(列出程序的PID和名称), cd到进入上一步文件夹执行python dump.py [名称] 1.2 Clutch安装及使用: https://github.com/KJCracks/Clutch 1.3 dumpdecrypted安装及使用: https://github.com/stefanesser/dumpdecrypted 2. 连接工具2.1 OpenSSH安装: 一般越狱时会自动安装, 也可以Cydia搜索安装.使用: 终端执行ssh root@[deviceIP], 然后输入密码(初始密码为alpine)连接.","categories":[],"tags":[{"name":"JailBreak","slug":"JailBreak","permalink":"http://yoursite.com/tags/JailBreak/"}]},{"title":"iOS JailBreak 问题收集","slug":"iOS-JailBreak-问题收集","date":"2018-01-18T02:43:13.000Z","updated":"2018-02-07T08:45:15.415Z","comments":true,"path":"2018/01/18/iOS-JailBreak-问题收集/","link":"","permalink":"http://yoursite.com/2018/01/18/iOS-JailBreak-问题收集/","excerpt":"","text":"class-dump 执行失败问题描述： 1，在ios逆向工程中，用 class-dump 可以导出App头文件；但是，从App Store 下载的App，都是加密过的，直接用 class-dump ，导出结果只会什么都没有，或者只有一个：CDStructures.h 文件；因此，对于这种情况，首先要做的就是：砸壳； 2，砸壳工具有：AppCrackr、Clutch、dumpcrypted 等；由于 AppCrackr 、Clutch 暴力砸壳、操作简单，招致公愤，因此一些核心功能，已经下架，在高级系统中，已不能使用；因此，推荐： dumpcrypted 砸壳工具。工具获取及使用方法，参考：https://github.com/stefanesser/dumpdecrypted 3，当砸壳完毕后，将砸壳生成的 *.decrypted 文件拷贝至MAC，之后使用 class-dump 导出头文件即可； 4，注意：当砸壳完毕后，使用 class-dump 仍然只导出 CDStructures.h 一个文件，则可能架构选择错误；因为 dumpdecrypted 只会砸你手机处理器对应的那个壳，fat binary 的其它部分仍然是有壳的，而 class-dump 的默认目标又不是被砸壳的那个部分，因此很有可能就会报错； 5，当出现4 中情况时，指定下架构即可，命令示例：class-dump –arch armv7 hello.decrypted -H -o ./heads/ 参考地址 apple’s default applications bundle identifier1234567891011121314151617181920212223242526272829303132333435This is the verified list as of iOS 9.3:App Store - com.apple.AppStoreCalculator - com.apple.calculatorCalendar - com.apple.mobilecalCamera - com.apple.cameraClock - com.apple.mobiletimerCompass - com.apple.compassContacts - com.apple.MobileAddressBookFaceTime - com.apple.facetimeFind Friends - com.apple.mobileme.fmf1Find iPhone - com.apple.mobileme.fmip1Game Center - com.apple.gamecenterHealth - com.apple.HealthiBooks - com.apple.iBooksiTunes Store - com.apple.MobileStoreMail - com.apple.mobilemailMaps - com.apple.MapsMessages - com.apple.MobileSMSMusic - com.apple.MusicNews - com.apple.newsNotes - com.apple.mobilenotesPhone - com.apple.mobilephonePhotos - com.apple.mobileslideshowPodcasts - com.apple.podcastsReminders - com.apple.remindersSafari - com.apple.mobilesafariSettings - com.apple.PreferencesStocks - com.apple.stocksTips - com.apple.tipsVideos - com.apple.videosVoice Memos - com.apple.VoiceMemosWallet - com.apple.PassbookWatch - com.apple.BridgeWeather - com.apple.weather","categories":[],"tags":[{"name":"JailBreak","slug":"JailBreak","permalink":"http://yoursite.com/tags/JailBreak/"}]},{"title":"面试题集","slug":"面试题集","date":"2017-08-16T06:29:13.000Z","updated":"2017-08-16T10:04:20.000Z","comments":true,"path":"2017/08/16/面试题集/","link":"","permalink":"http://yoursite.com/2017/08/16/面试题集/","excerpt":"","text":"1、单例如何实现？答：单例在ARC和MRC下略有不同，共同需要重写的方法：+ (instancetype)allocWithZone:(struct _NSZone *)zone,- (id)copyWithZone:(NSZone *)zone,- (id)mutableCopyWithZone:(NSZone *)zone. 在MRC还需要重写- (oneway void)release,- (instancetype)retain,- (NSUInteger)retainCount. 2、对于类方法(静态方法)默认是autorelease，所有类方法都这样吗？答：系统自带大多数类方法返回的对象都是经过autorelease. 3、自动释放池底层怎么实现答：自动释放池以栈的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作. 4、KVO内部实现原理答：1&gt; KVO是基于runtime机制实现的.2&gt; 当某个类的对象第一次被观察时， 系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法实现真正的通知机制（Person NSKVONotifying_Person）. 5、Foundation对象与Core Foundation对象有什么区别答：1&gt; Foundation对象是OC的，Core Foundation对象是C对象.2&gt; 数据类型之间的转换ARC:__bridge_retained、__bridge_transfer非ARC: __bridge","categories":[],"tags":[]},{"title":"GCD笔记","slug":"GCD笔记","date":"2017-08-09T01:58:00.000Z","updated":"2017-08-09T02:06:01.000Z","comments":true,"path":"2017/08/09/GCD笔记/","link":"","permalink":"http://yoursite.com/2017/08/09/GCD笔记/","excerpt":"","text":"GCD全称: Grand Central Dispatch，","categories":[],"tags":[]},{"title":"A List Of macOS Command Line","slug":"A-List-Of-macOS-Command-Line","date":"2017-06-09T02:22:04.000Z","updated":"2017-06-09T06:46:28.000Z","comments":true,"path":"2017/06/09/A-List-Of-macOS-Command-Line/","link":"","permalink":"http://yoursite.com/2017/06/09/A-List-Of-macOS-Command-Line/","excerpt":"","text":"An A-Z Index of the Apple macOS command line原网址: https://ss64.com/osx/","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"Xcode tips","slug":"Xcode-tips","date":"2017-05-08T06:00:04.000Z","updated":"2017-06-09T07:05:39.000Z","comments":true,"path":"2017/05/08/Xcode-tips/","link":"","permalink":"http://yoursite.com/2017/05/08/Xcode-tips/","excerpt":"1、Xcode 8.3无法使用PackageApplication提示：xcrun: error: unable to find utility &quot;PackageApplication&quot;, not a developer tool or in PATH.解决办法: 从Xcode 8.2拷贝PackageApplication到当先Xcode对应目录1) 下载PackageApplication:https://github.com/mgfjxxiexiaolong/FileBackUp/blob/master/PackageApplication2) 修改属性为可执行: chmod +x PackageApplication3) 拷贝到对应目录:1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication 参考地址","text":"1、Xcode 8.3无法使用PackageApplication提示：xcrun: error: unable to find utility &quot;PackageApplication&quot;, not a developer tool or in PATH.解决办法: 从Xcode 8.2拷贝PackageApplication到当先Xcode对应目录1) 下载PackageApplication:https://github.com/mgfjxxiexiaolong/FileBackUp/blob/master/PackageApplication2) 修改属性为可执行: chmod +x PackageApplication3) 拷贝到对应目录:1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication 参考地址","categories":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/categories/Xcode/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/tags/Xcode/"}]},{"title":"shell-tr命令","slug":"shell-tr命令","date":"2017-05-02T00:46:29.000Z","updated":"2017-05-02T01:31:05.000Z","comments":true,"path":"2017/05/02/shell-tr命令/","link":"","permalink":"http://yoursite.com/2017/05/02/shell-tr命令/","excerpt":"作用：tr 命令用于转换字符、删除字符和压缩重复的字符。它从标准输入读取数据并将结果输出到标准输出。 语法：tr [OPTION]... SET1 [SET2].如果参数 SET1 和 SET2 同时制定，并没有指定 -d 选项，那么 tr 命令将把 SET1 中指定的每个字符替换为 SET2 中相同位置的字符。","text":"作用：tr 命令用于转换字符、删除字符和压缩重复的字符。它从标准输入读取数据并将结果输出到标准输出。 语法：tr [OPTION]... SET1 [SET2].如果参数 SET1 和 SET2 同时制定，并没有指定 -d 选项，那么 tr 命令将把 SET1 中指定的每个字符替换为 SET2 中相同位置的字符。 ####示例：1.将输出文本转换为大写：cat filename | tr [:lower:] [:upper:]，还可以这样写：cat filename | tr a-z A-Z.2.转换一个文件的内容，并将转换的结果输出到另一个文件：tr &#39;originStr&#39; &#39;replaceStr&#39; &lt; originFileName &gt; newFileName.3.使用-d选项删除指定字符：echo &quot;My Name Is Toby&quot; | tr -d a-z,删除所有小写字母.","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"React-Native笔记","slug":"React-Native笔记","date":"2017-03-22T00:24:39.000Z","updated":"2017-03-22T00:56:31.000Z","comments":true,"path":"2017/03/22/React-Native笔记/","link":"","permalink":"http://yoursite.com/2017/03/22/React-Native笔记/","excerpt":"","text":"1、RN调用OC传参并调用方法1)建一个类继承自NSObject的类首先要导入#import &quot;RCTBridgeModule.h&quot;头文件，并遵守RCTBridgeModule协议,然后在实现类中： 1234#import \"RCTBridgeModule.h\"@interface MineRNBridgeModule : RCTEventEmitter&lt;RCTBridgeModule&gt;@end 12345678910#import \"MineRNBridgeModule.h\"@implementation MineRNBridgeModuleRCT_EXPORT_MODULE(MineRNBridgeModule);RCT_EXPORT_METHOD(RunOCMethod:(NSDictionary *)dictionary)&#123; NSLog(@\"接收到RN传过来的数据为:%@\",dictionary); //可以在此添加OC代码操作, RunOCMethod为方法名，后面的为参数&#125;@end 2)RN中实现代码:首先要引入NativeModules组件： 123var RNBridgeModule = NativeModules.MineRNBridgeModule;//在合适位置调用即可RNBridgeModule.RNInvokeOCCallBack(&#123;'name':'jiangqq','description':'http://www.lcode.org'&#125;); 2、OC向RN传参并调用方法参考: React-Native新版本RCTEventEmitter的使用（从原生发送消息到JS）1)自定义的模块类头文件要继承自RCTEventEmitter@interface ChivoxISE : RCTEventEmitter&lt;RCTBridgeModule&gt;2)然后要导出你所有的方法名字 1234- (NSArray&lt;NSString *&gt; *)supportedEvents &#123; return @[@\"iseCallback\", @\"iseVolume\", @\"playCallback\"];//有几个就写几个 &#125; 3)分别实现你导出的所有方法，里面都使用sendEventWithName方法即可 12345678-(void)iseCallback:(NSString*)code result:(NSString*) result &#123; [self sendEventWithName:@\"iseCallback\" body:@&#123; @\"code\": code, @\"result\": result, &#125;]; &#125; 4)最后JS端调用 1234567891011121314151617import &#123; ... NativeModules, NativeEventEmitter, //导入NativeEventEmitter模块 &#125; from 'react-native'; var ChivoxISE = NativeModules.ChivoxISE; const myNativeEvt = new NativeEventEmitter(ChivoxISE); //创建自定义事件接口 //在组件中使用 componentWillMount() &#123; this.listener = myNativeEvt.addListener('iseCallback', this.iseCallback.bind(this)); //对应了原生端的名字 &#125; componentWillUnmount() &#123; this.listener &amp;&amp; this.listener.remove(); //记得remove哦 this.listener = null; &#125;","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"PIL(Python Image Library)详解","slug":"PIL-Python-Image-Library-详解","date":"2017-03-10T03:10:08.000Z","updated":"2017-03-10T06:07:43.000Z","comments":true,"path":"2017/03/10/PIL-Python-Image-Library-详解/","link":"","permalink":"http://yoursite.com/2017/03/10/PIL-Python-Image-Library-详解/","excerpt":"","text":"1、打开、旋转、显示(默认图片浏览器)图片123from PIL import Imageim = Image.open(\"bride.jpg\")im.rotate(45).show() 2、创建缩略图12345678910from PIL import Imageimport glob, ossize = 128, 128for infile in glob.glob(\"*.jpg\"): file, ext = os.path.splitext(infile) im = Image.open(infile) im.thumbnail(size, Image.ANTIALIAS) im.save(file + \".thumbnail\", \"JPEG\") 为当前文件夹下所有JPG图片创建缩略图并存储","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"swift笔记","slug":"swift笔记","date":"2017-02-24T07:29:22.000Z","updated":"2017-02-28T03:15:49.000Z","comments":true,"path":"2017/02/24/swift笔记/","link":"","permalink":"http://yoursite.com/2017/02/24/swift笔记/","excerpt":"1.打印方法名称print(#function); swift3.0 or later(之前为__FUNCTION__) 2.swift使用block(闭包)回调先声明闭包typealias ScanFinish = (_ finish:Bool)-&gt;Void;再设置闭包函数为属性var block:ScanFinish?;,然后在初始化是赋值闭包属性就行了 3.@escaping 逃逸闭包swift3.0总取消了@noescapting(非逃逸闭包)，改为了@escaping(逃逸闭包)，区别：即闭包在函数内执行为非逃逸闭包，在函数外为逃逸闭包，在函数外执行需要@escaping修饰，例如：123456typealias ScanFinish = (_ finish:Bool)-&gt;Void;init(scanFinish: @escaping ScanFinish) &#123; super.init(nibName: nil, bundle: nil); self.block = scanFinish;//逃逸闭包 scanFinish(ture);//非逃逸闭包 &#125;","text":"1.打印方法名称print(#function); swift3.0 or later(之前为__FUNCTION__) 2.swift使用block(闭包)回调先声明闭包typealias ScanFinish = (_ finish:Bool)-&gt;Void;再设置闭包函数为属性var block:ScanFinish?;,然后在初始化是赋值闭包属性就行了 3.@escaping 逃逸闭包swift3.0总取消了@noescapting(非逃逸闭包)，改为了@escaping(逃逸闭包)，区别：即闭包在函数内执行为非逃逸闭包，在函数外为逃逸闭包，在函数外执行需要@escaping修饰，例如：123456typealias ScanFinish = (_ finish:Bool)-&gt;Void;init(scanFinish: @escaping ScanFinish) &#123; super.init(nibName: nil, bundle: nil); self.block = scanFinish;//逃逸闭包 scanFinish(ture);//非逃逸闭包 &#125;","categories":[],"tags":[]},{"title":"fuck shit","slug":"fuck-shit","date":"2017-01-23T03:20:17.000Z","updated":"2017-01-23T06:40:07.000Z","comments":true,"path":"2017/01/23/fuck-shit/","link":"","permalink":"http://yoursite.com/2017/01/23/fuck-shit/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Shell 使用小技巧","slug":"Shell使用小技巧","date":"2017-01-18T07:28:04.000Z","updated":"2017-04-28T06:38:04.000Z","comments":true,"path":"2017/01/18/Shell使用小技巧/","link":"","permalink":"http://yoursite.com/2017/01/18/Shell使用小技巧/","excerpt":"1、sed &#39;s/}/text}/g&#39; file:在文件file文件中的所有}之前添加text文本.例如:NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));打印当前方法名 waring:如果遇到sed: RE error: illegal byte sequence, 这是因为在识别含有多字节编码字符时遇到了解析冲突问题, 请在终端执行export LC_COLLATE=&#39;C&#39;和export LC_CTYPE=&#39;C&#39; 2、将文件夹下的所有文件或文件夹按字母分类123456789101112131415161718#! /usr/bin/bashpath=$1final=$&#123;path: -1&#125;echo final : $finalif [[ \"$&#123;final&#125;\" != \"/\" ]]; then path=$path/; echo hehe + $path;fiecho $pathfor file in `ls $path`;do subDir=$&#123;file:0:1&#125;; subDir=\"$(echo $subDir | tr '[A-Z]' '[a-z]')\" dirPath=$path$subDir; mkdir $dirPath; cp $path$file $dirPath;done","text":"1、sed &#39;s/}/text}/g&#39; file:在文件file文件中的所有}之前添加text文本.例如:NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));打印当前方法名 waring:如果遇到sed: RE error: illegal byte sequence, 这是因为在识别含有多字节编码字符时遇到了解析冲突问题, 请在终端执行export LC_COLLATE=&#39;C&#39;和export LC_CTYPE=&#39;C&#39; 2、将文件夹下的所有文件或文件夹按字母分类123456789101112131415161718#! /usr/bin/bashpath=$1final=$&#123;path: -1&#125;echo final : $finalif [[ \"$&#123;final&#125;\" != \"/\" ]]; then path=$path/; echo hehe + $path;fiecho $pathfor file in `ls $path`;do subDir=$&#123;file:0:1&#125;; subDir=\"$(echo $subDir | tr '[A-Z]' '[a-z]')\" dirPath=$path$subDir; mkdir $dirPath; cp $path$file $dirPath;done 用法：bash script.sh /directory/path 3、find技巧1.批量查找并拷贝到指定目录：find path -name &quot;*.gif&quot;| xargs -I {} cp {} targetPath 2.查找指定路径下所有文件并忽略隐藏文件及隐藏文件夹下的所有文件：find &lt;dir&gt; -path &quot;*/.*&quot; -prune -o -print 3.查找指定路径下指定文件并忽略隐藏文件及隐藏文件夹下的所有文件：find $PWD -path &#39;*/.*&#39; -prune -o \\( -name &#39;*.py&#39; -o -name &quot;*.sh&quot; \\) -type f -print","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"UIView的生命周期","slug":"UIView的生命周期","date":"2017-01-13T16:00:00.000Z","updated":"2017-01-23T02:17:52.000Z","comments":true,"path":"2017/01/14/UIView的生命周期/","link":"","permalink":"http://yoursite.com/2017/01/14/UIView的生命周期/","excerpt":"探寻UIView的生命周期。我们知道view的创建有init(或new)的方法，销毁时会自动执行dealloc方法，但是UIView的生命周期到底是怎样的呢？我们一步一步来。 首先新建一个项目并创建一个TestView继承自UIView： 再创建TestViewController继承自UIViewController，用于承载TestView(方便后面测试view销毁时间)：","text":"探寻UIView的生命周期。我们知道view的创建有init(或new)的方法，销毁时会自动执行dealloc方法，但是UIView的生命周期到底是怎样的呢？我们一步一步来。 首先新建一个项目并创建一个TestView继承自UIView： 再创建TestViewController继承自UIViewController，用于承载TestView(方便后面测试view销毁时间)：在Main.storyboard中给默认的控制器ViewController添加导航：在ViewController.m中添加如下代码用于跳转操作：123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame = CGRectMake(100, 100, 100, 100); btn.backgroundColor = [UIColor colorWithRed:0.489 green:0.548 blue:0.898 alpha:1.000]; [btn setTitle:@\"push\" forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [btn addTarget:self action:@selector(pushTestViewVC:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;- (void)pushTestViewVC:(UIButton *)sender&#123; TestViewController *vc = [[TestViewController alloc] init]; [self.navigationController pushViewController:vc animated:YES]; &#125; 在TestViewController.m中添加如下代码:12345678910- (void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; TestView *view = [[TestView alloc] init]; view.frame = CGRectMake(8, 100, self.view.bounds.size.width - 8*2, 250); view.backgroundColor = [UIColor colorWithRed:0.101 green:0.502 blue:0.427 alpha:1.000]; [self.view addSubview:view]; &#125; ok,到这儿准备工作完成。运行一下： 查看UIViewapi，常用的加载时机大概如下：- (void)layoutSubviews- (void)didAddSubview:(UIView *)subview;- (void)willRemoveSubview:(UIView *)subview;- (void)willMoveToSuperview:(nullable UIView *)newSuperview;- (void)didMoveToSuperview;- (void)willMoveToWindow:(nullable UIWindow *)newWindow;- (void)didMoveToWindow;- (void)removeFromSuperview- (void)dealloc一一在TestView.m中实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import \"TestView.h\"@interface TestView ()&#123; NSInteger count;&#125;@end@implementation TestView- (instancetype)init&#123; self = [super init]; if (self) &#123; count = 0; &#125; return self;&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)didAddSubview:(UIView *)subview&#123; [super didAddSubview:subview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)willRemoveSubview:(UIView *)subview&#123; [super willRemoveSubview:subview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)willMoveToSuperview:(nullable UIView *)newSuperview&#123; [super willMoveToSuperview:newSuperview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)didMoveToSuperview&#123; [super didMoveToSuperview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)willMoveToWindow:(nullable UIWindow *)newWindow&#123; [super willMoveToWindow:newWindow]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)didMoveToWindow&#123; [super didMoveToWindow]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)removeFromSuperview&#123; [super removeFromSuperview]; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;- (void)dealloc&#123; count++; NSLog(@\"%@ ==&gt; %ld\",NSStringFromSelector(_cmd),count);&#125;@end *_cmd表示当前方法的SEL，既执行该方法时打印方法名* 运行，点push，控制台打印如下： 然后点击navigation的back按钮： 我们发现- (void)didAddSubview:(UIView *)subview;- (void)willRemoveSubview:(UIView *)subview;这两个是需要有子视图才能执行，暂时不做讨论。可以看出上面方法中只会执行一次的方法有removeFromSuperview、dealloc两个方法(layoutSubviews在子视图布局变动时会多次调用)，所以可以在这两个方法中执行释放内存等操作(e.g:移除观察者，定时器等)。 OK，下面我们讨论关于subView的几个方法，首先在TestViewController.m中实现点击按钮给testView添加子视图的功能： 123456789101112131415161718192021222324252627282930313233#import \"TestViewController.h\"#import \"TestView.h\"@interface TestViewController ()&#123; TestView *testView;&#125;@end@implementation TestViewController- (void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor lightGrayColor]; UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithTitle:@\"addSubView\" style:UIBarButtonItemStylePlain target:self action:@selector(addTestViewSubView)]; self.navigationItem.rightBarButtonItem = item; TestView *view = [[TestView alloc] init]; view.frame = CGRectMake(8, 100, self.view.bounds.size.width - 8*2, 250); view.backgroundColor = [UIColor colorWithRed:0.101 green:0.502 blue:0.427 alpha:1.000]; [self.view addSubview:view]; testView = view; &#125;- (void)addTestViewSubView&#123; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)]; view.backgroundColor = [UIColor lightGrayColor]; view.tag = 100; [testView addSubview:view]; &#125;@end 点击push后点击按钮添加子视图：可见didAddSubview和layoutSubviews都调用了，那我们pop回去：willRemoveSubview是在dealloc后面执行的，通过断点我们发现确实是最后执行的。而且如果有多个子视图，willRemoveSubview会循环执行，直到移除所有子视图。 以上执行顺序比较清楚，主要是了解UIView的各个时机便于我们进行相关操作。关于：- (void)willMoveToSuperview:(nullable UIView *)newSuperview;- (void)willMoveToWindow:(nullable UIWindow *)newWindow;这俩个方法可以根据参数是否为nil判断是创建操作还是销毁操作，nil则为销毁，反之，则为创建；- (void)didMoveToSuperview;这个方法可以根据self.superview的值判定，nil则为销毁，反之，则为创建。- (void)didMoveToWindow;这个方法可以根据self.superview的值判定，nil则为创建，反之，则为销毁。(注意这个方法和上面的是相反的) 如有错误的地方，麻烦指正。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}